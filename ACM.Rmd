---
title: "ACM"
author: "Bracq, Raymond"
date: "17/03/2024"
output:
  html_notebook: 
    encoding: UTF-8
  pdf_document: default
  html_document:
    df_print: paged
    encoding: UTF-8
editor_options:
  markdown:
    wrap: 72
---

# ACM

L'idée c'est qu'il faut tout recoder de manière à ce qu'il n'y ait pas de modalités avec très peu de personnes (cette modalité surdetermine le graphe). On recode avec irec de questionr et on vérifie au préalable avec des svytable.
Il faut aussi vérifier qu'on a pas de NA (les lignes avec un NA vont être supprimées dans l'ACM).

```{r, include = FALSE}
library(tidyverse)
library(questionr)
library(FactoMineR)
library(factoextra)
library(explor)
library(Factoshiny)
library(forcats)
```

## Préparation de la base

```{r}
# indiv$agenq_cat <- cut(indiv$agenq, breaks = c())
indiv <- indiv %>% 
  mutate(compor_discri = case_when(i_controla_a == 0 |i_controlb_d == 0|i_controla_f ==0|i_controlb_b == 0 ~ "Discrimination dans le comportement de la police par le négatif",
        i_controla_b == 1 | i_controla_c ==1 | i_controla_d == 1 | i_controla_e ==1 | i_controlb_a ==1 | i_controlb_c == 1 | i_controlb_e ==1 | i_controlb_f==1 ~ "Discrimination dans le comportement de la police par le positif",
        i_controlagr_flag %in% c(-1, -2) ~ "Refus ou ne sait pas",
        i_controlagr_flag == 0 ~ "Pas de contrôle de police",
                                   TRUE ~ "Pas de comportement discriminatoire lors du dernier contrôle"))
```


```{r}
indiv_acm1 <- indiv %>%
  filter(i_cnfpol_rec!="Refus ou ne sait pas", i_contri_rec!="Refus ou ne sait pas", d_lieudisagr_d_rec!="Refus ou ne sait pas") %>% 
  select(i_cnfpol_rec, i_contri_rec, d_lieudisagr_d_rec, origine_tous_g2_rec, group1_rec, l_immi_rec, a_rquart_code, l_quart_secu_rec, qpv_i_rec, compor_discri, sexee_rec, group1, csnq_ego_rec, durtotfrm, durar2, agenq, ident, poidsi) #, durtotfrm, durar2, agenq

rownames(indiv_acm1) <- paste(indiv_acm1$ident)
indiv_acm1_poids <- indiv_acm1 %>% select(-ident) 

indiv_acm1 <- indiv_acm1_poids %>% select(-poidsi)


indiv_acm1_poids <- indiv_acm1_poids%>% filter(indiv_acm1$group1 == "1")
```

```{r}
indices_to_exclude <- which(indiv_acm1$group1 != "1")
indices_to_include <- which(indiv_acm1$group1 == "1")
indices <- c(indices_to_exclude, indices_to_include)
```




## Réalisation de l'ACM sur toute la pop
On tente une première ACM avec en actif les variables sur la police. 

```{r}
res1 <- MCA(indiv_acm1, ind.sup = indices[8000:15000], quali.sup = 4:13, quanti.sup = 14:16)#les supplémentaires sont aux rang 8à 16#quanti.sup = c(8, 11),

```


```{r}
explor(res)
HCPCshiny(res)# ça permet de voir le graphe tester des choses, produire un rapport automatique et tester la classification
```

On pourra en tenter une autre avec en actif les autres variables.


## ACM que sur immigrés

```{r}
indiv_acm2 <- indiv %>%
  filter(i_cnfpol_rec!="Refus ou ne sait pas", i_contri_rec!="Refus ou ne sait pas", d_lieudisagr_d_rec!="Refus ou ne sait pas") %>% 
    filter(group1_code == "G1_I") %>% 
  select(i_cnfpol_rec, i_contri_rec, d_lieudisagr_d_rec, origine_tous_g2_rec, l_immi_rec, a_rquart_code, l_quart_secu_rec, qpv_i_rec, sexee_rec, csnq_ego_rec, compor_discri, durtotfrm, durar2, agenq, ident, poidsi)  

rownames(indiv_acm2) <- paste(indiv_acm2$ident)
indiv_acm2_poids <- indiv_acm2 %>% select(-ident) 

indiv_acm2 <- indiv_acm2_poids %>% select(-poidsi)

```

```{r}
res <- MCA(indiv_acm2, quali.sup = 4:11, quanti.sup = 12:14, row.w = indiv_acm2_poids$poidsi)
#les supplémentaires sont aux rang 8à 16#quanti.sup = c(8, 11),
```

```{r}
res.MCA<-MCA(X = indiv_acm2, quanti.sup = 12:14, quali.sup = 4:11, row.w = indiv_acm2_poids$poidsi)
res.HCPC<-HCPC(res.MCA,nb.clust=6,consol=FALSE,graph=FALSE)
plot.HCPC(res.HCPC,choice='tree',title='Arbre hiérarchique')
plot.HCPC(res.HCPC,choice='map',draw.tree=FALSE,title='Plan factoriel')
plot.HCPC(res.HCPC,choice='3D.map',ind.names=FALSE,centers.plot=FALSE,angle=60,title='Arbre hiérarchique sur le plan factoriel')
```

Classe 1 : Pas de discri, confiance dans la police, jamais contrôlé
femmes, bonne sécurité, G1 Maroc Tunisie Algérie, Classe pop

Classe 2 : Discri autre, plutôt confiance, jamais contrôlé
femmes, chine, pas QPV, classes sup

Classe 3 : Décla discri autre, contrôlé une fois
hommes, discri police par compor

Classe 4 : Discri autre, plutôt pas confiance, jamais contrôlé
Mauvaise sécu de quartier, chine, femmes, QPV

Classe 5 : Discri police, contrôle 2 à 5 fois, pas confiance
hommes, Afrique guinéenne et centrale, sécurité mauvaise, ségrégation QPV

Classe 6 : Plus de 5, pas confiance
Afrique sahélienne ou autres pays d'Afrique


### Cours ENS - sans utiliser Factoshiny
Peut être utile si on veut pas passer par Shiny parce que la base est trop lourde
```{r, include = FALSE}
### ACM ---------
# premi�re tentative
tt_acm <- tt[, c("DIP2", "SEXE", "concours", "cl_AGE", "contrat", "filiere", "secteur")]
tt_acm <- lapply(tt_acm[,], factor)  ## passer tout en facteur
tt_acm <- as.data.frame(tt_acm)

res <- MCA(tt_acm) # 
explor(res)

# Deuxi�me tentative
tt_acm <- tt[, c("DIP2", "SEXE", "filiere", "cl_AGE", "contrat", "secteur2", "tps_partiel", "traj_statut", "pcs", "traj_cho", "traj_empl")] # retrait de "concours"
tt_acm <- lapply(tt_acm[,], factor)  ## passer tout en facteur
tt_acm <- as.data.frame(tt_acm)

res <- MCA(tt_acm, quali.sup = 6) # la 6eme variable de la liste (variable "secteur2") est ajout�e en suppl�mentaire
explor(res)
    
table(tt$DIP2)

### CLASSIFICATIONS ----

# faire la classification par classfication ascendante hierarchique (CAH, HCPC en anglais)
classif <- HCPC(res, graph = FALSE) 

#repr�sentations
plot.HCPC(classif, choice = "tree") # dessin du dendogramme
plot.HCPC(classif, choice = "map") # repr�sentation en nuage : utile si peu d'individus

# repr�sentations plus jolies (mais plus longues � faire)
fviz_dend(classif, show_labels = FALSE)
fviz_cluster(classif, geom = "point", main = "Factor map")

# choix du nombre de classes
classif <- HCPC(res, graph = FALSE, nb.clust = 3) # chercher un saut, 3 classes semblent pertinentes

#### QUALIFIER LES CLASSES
# par les individus (utile surtout si individus ont des noms, cf cas des communes d'IdF)
classif$desc.ind$para # parangons, ie individus moyens de chaque classe
classif$desc.ind$dist # individus les plus extremes, qui accentuent les cara de la classe

# par les variables
classif$desc.var$test.chi2 # variables qui sont les plus discriminantes
classif$desc.var #pour le d�coupage en classes

# R�introduire les classes ds la base
classif$data.clust # contient la classe pour chaque individu
names(classif$data.clust) # pour rep�rer le num�ro de la colonne "clust" (ici : 12)
clust <- classif$data.clust[,12] # on ne conserve que la colonne contenant les classes
tt <- cbind(tt, clust) # on l'ajoute � la table initiale : on a bien une variable clust qui contient la classe � laquelle appartient l'individu

# on peut ensuite regarder les caract�ristiques pour chaque classe (ici le type de contrat)
tb <- table(tt$clust, tt$contrat) # avec une var quali
cprop(tb)
rprop(tb)

tapply(tt$AGE, tt$clust, mean) # avec une variable quanti (ici age moyen de chaque classe)


#### RETOUR ACM ----
tt_acm <- tt[, c("DIP2", "SEXE", "filiere", "cl_AGE", "contrat", "secteur2", "tps_partiel", "traj_statut", "pcs", "traj_cho", "traj_empl", "clust")]

tt_acm <- lapply(tt_acm[,], factor)  ## passer tout en facteur
tt_acm <- as.data.frame(tt_acm)

res <- MCA(tt_acm, quali.sup = c(6,12))
explor(res)




```

### Code mémoire
```{r}
acm <- indiv_dist %>% select(s_medeciq_a, s_medeciq_b, s_medeciq_c, s_medeciq_e, s_medeciq_f, s_etat_rec, s_medeciq_g, s_ren_queren_spe, s_ren_queren_gen, s_ren_queren_dent, s_ren_queren_medoc, s_ren_queren_lun, s_ren_queren_analyses, s_ren_queren_imagerie,  s_rec_ren_gen, s_rec_ren_spe, s_renonc_acm, s_medeciq_acm, s_ren_pqren_cout, s_ren_pqren_attente, s_ren_pqren_qui, s_ren_pqren_papier, s_ren_pqren_peur, s_ren_pqren_tps_loin,l_immi, group1, origine_tous_g2, sexee, csnq_ego, s_secuq, s_secuq_refus, dureeorigine,  s_traite, s_traite_peau,  s_maladi, s_limite, s_medeciq_d, frott_ap_25, agenq, durtotfrm, imc,ident_fa, poidsi) %>% data.frame() %>% 
  filter(!is.na(s_medeciq_a)&!is.na(s_medeciq_b)&!is.na(s_medeciq_c)&!is.na(s_medeciq_e)&!is.na(s_medeciq_f))

#, matches("^iris_pct_im\\w*$"), matches("^dist_min\\w*$"), matches("^com_apl_\\w*$"),  matches("^lib_dist_min\\w*$")
rownames(acm) <- paste(acm$ident_fa)
# acm$s_renonc <- acm$s_renonc %>%
#   fct_recode(
#     "A renoncé à des soins" = "Oui",
#     "N'a pas renoncé à des soins" = "Non",
#     NULL = "Refus (ne pas lire)",
#     NULL = "NSP (ne pas lire)"
#   )
acm_poids <- acm %>% select(-ident_fa) 
# %>% na.omit()
acm <- acm_poids %>% select(-poidsi)
```

